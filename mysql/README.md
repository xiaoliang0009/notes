# MySQL

* MySQL

```text
- TPS 数据库的每秒传输的事物处理个数
- QPS 数据库的每秒查询处理量

尽量不要让字段的默认值为 NULL，索引不会包含有 NULL值的列。

MySQL 的锁机制基本都是采用悲观锁来实现的

select for update 排他锁(悲观锁)
  - 仅适用于 InnoDB
  - 必须在事务块(BEGIN/COMMIT)中才能生效
  - 例子：select * from goods where id < 10 for update;
    通过 `for update` 语句, MySQL 会对查询结果集中每行数据都添加排它锁,
    其他线程对该记录的更新和删除操作都会阻塞
  - 排它锁包含行锁、表锁

行锁：
基于索引加载的，所以行锁是要加在索引响应行上，即命中索引
锁冲突概率低，并发性高，但会有死锁的情况出现

表锁：
响应的是非索引字段，即全表扫描，由于表锁每次都是锁一整张表，所以表锁的锁冲突的几率特别高，表锁不会出现死锁的情况

总结： 更新数据时，如果没有触发索引，则会锁表，锁表后再对表做任何变更操作都会导致锁冲突，所以表锁的锁冲突概率比较高。

记录锁：
出现条件必须是精准命中索引并且索引是唯一索引。行锁衍生

间隙锁：
查询条件命中锁，并且没有查询到符合条件的记录。行锁衍生
```

## Zookeeeper

锁： 排队取号，号在前面的先执行。

1、先创建持久节点，然后获得锁的进程都会在这个节点下创建临时顺序节点，可以规定排号最小的那个获得节点 2、节点监听机制，如果不是第一个节点，监听上一个节点的通知， 先抢号创建自己的ZNode，释放锁的时候，删除抢号的ZNode，然后就通知到下一个节点了

* 临时顺序节点
* 持久节点

## Redis

数据结构，对应的应用场景：

* String ： key value的形式，最大能存512MB
* hash ：    key hashmap的形式
* list ： 链表，主要应用于消息队列的实现。轻量级，没有重试重放机制
* set ： 无排序且不允许重复，比如保存一些标签

锁： 先setnx 设置一个锁，再设置一个过期时间，然后其他进程 setnx 设置锁时， 会因为锁已存在，返回 false，然后根据返回值sleep 然后再重试。 直到之前的进程释放锁。

缺陷：极端情况下，主服务器向从服务器同步时，宕机，从服务器在选举新的主服务器时，锁丢失

## I/O 多路复用

* select
* poll
* epoll \(event poll\)

