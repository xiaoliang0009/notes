# Cache

### 为什么要做缓存

为了提高响应速度，为了充分发挥服务器的机器性能，一般后端来说的话，数据库的影响比重是比较大的，我们会用缓存去减少数据库的查询，提高请求的响应时间。

### 怎么去做缓存

一般都是用 Redis 来做缓存，Redis 的数据结构用 hash 比较多，将数据库查的数据序列化，然后存在 Redis 中，下次直接查缓存就可以了，减少数据库的压力。

* 做缓存后会带来怎样额外的问题： 当然用缓存能显而易见提升响应速度，但是会带来：
  1. 缓存与数据库双写不一致

     读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先更新数据库，然后再删除缓存。

  2. 缓存雪崩、缓存穿透
* 缓存穿透

定义 ：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。

解决方案：

1. 布隆过滤器

   先准备要存储的key写入到布隆过滤器中，然后有新的请求key过来，验证key是否在布隆过滤器中。

   * 布隆过滤器说某个元素在，可能会被误判。
   * 布隆过滤器说某个元素不在，那么一定不在。

2. 如果key查询的结果为空，还是把空数据进行缓存，过期时间设置短点。下次请求相同缓存就不会出现缓存穿透的问题。
3. 缓存击穿

定义：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

解决方案：

​ 1. mutex \(互斥锁\) ，get 的时候缓存没有数据，然后加锁，从数据库读取数据，写入到缓存中，再解锁。

* 缓存雪崩

定义：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统\(比如DB\)带来很大压力。与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key。

解决方案：

1. 为key设置随机不同的缓存失效时间，防止集中在某一时间段失效。
2. 加锁排队，在读取数据的时候加锁，其他线程的读取会被阻塞。

   加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。

## Redis

数据结构，对应的应用场景：

* String ： key value的形式，最大能存512MB
* hash ：    key hashmap的形式
* list ： 链表，主要应用于消息队列的实现。轻量级，没有重试重放机制
* set ： 无排序且不允许重复，比如保存一些标签

锁： 先setnx 设置一个锁，再设置一个过期时间，然后其他进程 setnx 设置锁时， 会因为锁已存在，返回 false，然后根据返回值sleep 然后再重试。 直到之前的进程释放锁。

缺陷：极端情况下，主服务器向从服务器同步时，宕机，从服务器在选举新的主服务器时，锁丢失

